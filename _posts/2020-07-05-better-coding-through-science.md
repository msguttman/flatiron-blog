---
layout: post
title:  "Better Learning Through Science"
date:   2020-07-05 22:00:00 -0500
categories: coding science
---

>"Contrary to what most mathemeticians since antiquity have believed, and believe to this day, proof theory can never be made into a branch of mathematics. Proof theory is a science: specifically, it is computer science"  
> ~ David Deutsch, The Beginning of Infinity

At 35 years old, after years of inconsistent dabbling, I am finally "learning to code" in earnest.  One of the mixed blessings of the modern technology sector is the ubiquity of freely available educational resources.  This means that the main problem facing an aspiring learner is not how to find information, but *how to synthesize it efficiently and quickly.*  **Understanding how people learn can help anyone to learn faster and more effectively.**  

**People learn by making theories about the world and then testing them against observations.**  

In many cases the experimental nature of learning is not obvious, but programming is one of the most straightforward examples, especially for beginners working with more 'raw code'.  I want to advertize one simple idea to anyone learning to program, which I hope and expect will pay dividends over time.

## Make Specific Theories

>"The most important cultural expectation, one every mathematician knows, is that the
second you see a definition in a text you must immediately write down examples... The unspoken rule is that the reader may not continue unless the reader understands what the definition is saying."  
>~Jeremy Kun, A Programmer's Introduction to Mathematics

{% include vickitweet.html %}

One of the delights of programming is how safely one can make most mistakes.  Endless tools facilitate rapid testing and recovery from failed tests.  And certainly rapid testing is the best way to learn and improve.  But this can encourage an insidious habit: random changes.

When new students are used to working with relatively contrived lessons, and used to testing against pre-determined outcomes, it can *appear to work* to just keep guessing in a promising direction with many iterations of code.  There are only a few tools available at the beginning anyway, and **eventually one of them works.  The test passes, the output looks right-ish, and so one can move on.**  

## ~~Test~~Experiment-Driven-Development

Agile and TDD are ascendent because of any cultural fashion or fad, but because of this deep truth about the nature of programming.  Every time a program runs it gives you, the programmer, the chance to test a theory.  Every output is a proof that it is the result of the given operation on the input.  By knowing *why* you expect your most recent change to produce a better result, you will remember more easily how that facet of programming works.  This might be a theory about how a particular method will interact with a particular data structure, or it might be a theory about whether your wifi could have gone down in the last 30 seconds.  Practicing this habit will cost precious minutes when you might already be frustrated with error messages.  But making explicit assumptions now will lead to a clearer understanding of the way each part of your system works, which will over time lead to a more robust framework of associations in general.  And the more complex and convoluted the codebase, the more necessary it will be to take this systemic approach.  Good habits pay off in the long run.